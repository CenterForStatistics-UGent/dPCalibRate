
<!---
Copyright 2017 Matthijs Vynck
[//]: # (Comment) This program is free software: you can redistribute it and/or modify
[//]: # (Comment) it under the terms of the GNU General Public License as published by
[//]: # (Comment) the Free Software Foundation, either version 3 of the License, or
[//]: # (Comment) any later version.
[//]: # (Comment)
[//]: # (Comment) This program is distributed in the hope that it will be useful,
[//]: # (Comment) but WITHOUT ANY WARRANTY; without even the implied warranty of
[//]: # (Comment) MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
[//]: # (Comment) GNU General Public License for more details.
[//]: # (Comment)
[//]: # (Comment) You should have received a copy of the GNU General Public License
[//]: # (Comment) along with this program.  If not, see <http://www.gnu.org/licenses/>.
[//]: # (Comment)
[//]: # (Comment) Topic: R Markdown file for generating a digital PCR calibration report
[//]: # (Comment) Author: Matthijs.Vynck@UGent.be
[//]: # (Comment) Modified by: -
[//]: # (Comment) Date created: March 3, 2017
[//]: # (Comment) Last updated: September 20, 2017
-->

---
output: pdf_document
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhead{}
- \fancyfoot[LE,LO]{Report generated by dPCalibRate v1.1 on `r format(Sys.time(), '%B %d, %Y')`}
- \fancyfoot[RE,RO]{\thepage}
- \fancyfoot[CE,CO]{}
- \fancypagestyle{plain}{\pagestyle{fancy}}
---

`r input$reportTitle`
=======================

Results
=======================

```{r echo=FALSE}
#FUNCTIONS FROM MBESS PACKAGE
ci.cv <- function (cv = NULL, mean = NULL, sd = NULL, n = NULL, data = NULL, 
    conf.level = 0.95, alpha.lower = NULL, alpha.upper = NULL, 
    ...) 
{
    if (is.null(conf.level)) {
        if (alpha.lower >= 1 | alpha.lower < 0) 
            stop("'alpha.lower' is not correctly specified.")
        if (alpha.upper >= 1 | alpha.upper < 0) 
            stop("'alpha.upper' is not correctly specified.")
    }
    if (!is.null(conf.level)) {
        if (!is.null(alpha.lower) | !is.null(alpha.upper)) 
            stop("Since 'conf.level' is specified, 'alpha.lower' and 'alpha.upper' should be 'NULL'.")
        alpha.lower <- (1 - conf.level)/2
        alpha.upper <- (1 - conf.level)/2
    }
    if (is.null(data) & is.null(cv)) {
        if (is.null(mean)) 
            stop("Either input the whole data set using 'data' or specify the sample mean.")
        if (mean <= 0) 
            stop("The sample mean must be some non-zero positive value (Does taking the absolute value of the mean make sense?).")
        if (is.null(sd)) 
            stop("Either input the whole data set using 'data' or specify the sample standard deviation (using 'n'-1 in the denominator).")
        if (is.null(n)) 
            stop("Either input the whole data set using 'data' or specify the sample size")
        k <- sd/mean
        ncp.estimate <- sqrt(n)/k
        CI.NCP <- conf.limits.nct(ncp = ncp.estimate, df = n - 
            1, alpha.lower = alpha.upper, alpha.upper = alpha.lower, 
            conf.level = NULL)
        Low.lim <- CI.NCP$Upper.Limit
        Up.lim <- CI.NCP$Lower.Limit
        Low.Lim <- sqrt(n)/Low.lim
        Up.Lim <- sqrt(n)/Up.lim
        if (Up.lim <= 0) 
            Up.Lim <- Inf
        Result <- list(Lower.Limit.CofV = Low.Lim, Prob.Less.Lower = alpha.lower, 
            Upper.Limit.CofV = Up.Lim, Prob.Greater.Upper = alpha.upper, 
            C.of.V = k, C.of.V.Unbiased = k * (1 + 1/(4 * n)))
        if (alpha.lower == 0) 
            Result <- list(Lower.Limit.CofV = -Inf, Prob.Less.Lower = 0, 
                Upper.Limit.CofV = Up.Lim, Prob.Greater.Upper = alpha.upper, 
                C.of.V = k, C.of.V.Unbiased = k * (1 + 1/(4 * 
                  n)))
        if (alpha.upper == 0) 
            Result <- list(Lower.Limit.CofV = Low.Lim, Prob.Less.Lower = alpha.lower, 
                Upper.Limit.CofV = Inf, Prob.Greater.Upper = 0, 
                C.of.V = k, C.of.V.Unbiased = k * (1 + 1/(4 * 
                  n)))
        if (Up.Lim == Inf) 
            Result[4] <- 0
        if (round((Result$Prob.Less.Lower + Result$Prob.Greater.Upper), 
            3) != round((alpha.lower + alpha.upper), 3)) 
            warning("The computed confidence interval does not have the same coverage as the specified confidence interval.", 
                call. = FALSE)
        return(Result)
    }
    if (!is.null(data) & is.null(cv)) {
        if (!is.null(mean)) 
            stop("Since 'data' is specified, do not specify the 'mean'.")
        if (!is.null(sd)) 
            stop("Since 'data' is specified, do not specify the 'sd'.")
        if (!is.null(n)) 
            stop("Since 'data' is specified, do not specify the 'n'.")
        n <- length(data)
        sd.data <- (var(data))^0.5
        mean.data <- mean(data)
        k <- sd.data/mean.data
        ncp.estimate <- sqrt(n)/k
        CI.NCP <- conf.limits.nct(ncp = ncp.estimate, df = n - 
            1, alpha.lower = alpha.upper, alpha.upper = alpha.lower, 
            conf.level = NULL)
        Low.lim <- CI.NCP$Upper.Limit
        Up.lim <- CI.NCP$Lower.Limit
        Low.Lim <- sqrt(n)/Low.lim
        Up.Lim <- sqrt(n)/Up.lim
        if (Up.lim <= 0) 
            Up.Lim <- Inf
        Result <- list(Lower.Limit.CofV = Low.Lim, Prob.Less.Lower = alpha.lower, 
            Upper.Limit.CofV = Up.Lim, Prob.Greater.Upper = alpha.upper, 
            C.of.V = k, C.of.V.Unbiased = k * (1 + 1/(4 * n)))
        if (alpha.lower == 0) 
            Result <- list(Lower.Limit.CofV = -Inf, Prob.Less.Lower = 0, 
                Upper.Limit.CofV = Up.Lim, Prob.Greater.Upper = alpha.upper, 
                C.of.V = k, C.of.V.Unbiased = k * (1 + 1/(4 * 
                  n)))
        if (alpha.upper == 0) 
            Result <- list(Lower.Limit.CofV = Low.Lim, Prob.Less.Lower = alpha.lower, 
                Upper.Limit.CofV = Inf, Prob.Greater.Upper = 0, 
                C.of.V = k, C.of.V.Unbiased = k * (1 + 1/(4 * 
                  n)))
        if (Up.Lim == Inf) 
            Result[4] <- 0
        if (round((Result$Prob.Less.Lower + Result$Prob.Greater.Upper), 
            3) != round((alpha.lower + alpha.upper), 3)) 
            warning("The computed confidence interval does not have the same coverage as the specified confidence interval.", 
                call. = FALSE)
        return(Result)
    }
    if (!is.null(cv)) {
        k <- cv
        if (is.null(n)) 
            stop("Since you specified the coefficient of variation directly ('cv'), you must specify the sample size.")
        if (!is.null(data)) 
            stop("Since you specified the coefficient of variation ('cv') directly, do not include the raw data.")
        if (!is.null(mean)) 
            stop("Since you specified the coefficient of variation ('cv') directly, do not specify the mean ('mean').")
        if (!is.null(sd)) 
            stop("Since you specified the coefficient of variation ('cv') directly, do not specify the standard deviation ('sd').")
        ncp.estimate <- sqrt(n)/k
        CI.NCP <- conf.limits.nct(ncp = ncp.estimate, df = n - 
            1, alpha.lower = alpha.upper, alpha.upper = alpha.lower, 
            conf.level = NULL)
        Low.lim <- CI.NCP$Upper.Limit
        Up.lim <- CI.NCP$Lower.Limit
        Low.Lim <- sqrt(n)/Low.lim
        Up.Lim <- sqrt(n)/Up.lim
        if (Up.lim <= 0) 
            Up.Lim <- Inf
        Result <- list(Lower.Limit.CofV = Low.Lim, Prob.Less.Lower = alpha.lower, 
            Upper.Limit.CofV = Up.Lim, Prob.Greater.Upper = alpha.upper, 
            C.of.V = k, C.of.V.Unbiased = k * (1 + 1/(4 * n)))
        if (alpha.lower == 0) 
            Result <- list(Lower.Limit.CofV = -Inf, Prob.Less.Lower = 0, 
                Upper.Limit.CofV = Up.Lim, Prob.Greater.Upper = alpha.upper, 
                C.of.V = k, C.of.V.Unbiased = k * (1 + 1/(4 * 
                  n)))
        if (alpha.upper == 0) 
            Result <- list(Lower.Limit.CofV = Low.Lim, Prob.Less.Lower = alpha.lower, 
                Upper.Limit.CofV = Inf, Prob.Greater.Upper = 0, 
                C.of.V = k, C.of.V.Unbiased = k * (1 + 1/(4 * 
                  n)))
        if (Up.Lim == Inf) 
            Result[4] <- 0
        if (round((Result$Prob.Less.Lower + Result$Prob.Greater.Upper), 
            3) != round((alpha.lower + alpha.upper), 3)) 
            warning("The computed confidence interval does not have the same coverage as the specified confidence interval.", 
                call. = FALSE)
        return(Result)
    }
}

conf.limits.nct <- function (ncp, df, conf.level = 0.95, alpha.lower = NULL, alpha.upper = NULL, 
    t.value, tol = 1e-09, sup.int.warns = TRUE, ...) 
{
    if (missing(ncp)) {
        if (missing(t.value)) 
            stop("You need to specify either 'ncp' or its alias, 't.value,' you have not specified either")
        ncp <- t.value
    }
    if (df <= 0) 
        stop("The degrees of freedom must be some positive value.", 
            call. = FALSE)
    if (abs(ncp) > 37.62) 
        #print("The observed noncentrality parameter of the noncentral t-distribution has exceeded 37.62 in magnitude (R's limitation for accurate probabilities from the noncentral t-distribution) in the function's iterative search for the appropriate value(s). The results may be fine, but they might be inaccurate; use caution.")
    if (sup.int.warns == TRUE) 
        Orig.warn <- options()$warn
    options(warn = -1)
    if (!is.null(conf.level) & is.null(alpha.lower) & !is.null(alpha.upper)) 
        stop("You must choose either to use 'conf.level' or define the 'lower.alpha' and 'upper.alpha' values; here, 'upper.alpha' is specified but 'lower.alpha' is not", 
            call. = FALSE)
    if (!is.null(conf.level) & !is.null(alpha.lower) & is.null(alpha.upper)) 
        stop("You must choose either to use 'conf.level' or define the 'lower.alpha' and 'upper.alpha' values; here, 'lower.alpha' is specified but 'upper.alpha' is not", 
            call. = FALSE)
    if (!is.null(conf.level) & is.null(alpha.lower) & is.null(alpha.upper)) {
        alpha.lower <- (1 - conf.level)/2
        alpha.upper <- (1 - conf.level)/2
    }
    .conf.limits.nct.M1 <- function(ncp, df, conf.level = NULL, 
        alpha.lower, alpha.upper, tol = 1e-09, sup.int.warns = TRUE, 
        ...) {
        if (sup.int.warns == TRUE) 
            Orig.warn <- options()$warn
        options(warn = -1)
        min.ncp = min(-150, -5 * ncp)
        max.ncp = max(150, 5 * ncp)
        .ci.nct.lower <- function(val.of.interest, ...) {
            (qt(p = alpha.lower, df = df, ncp = val.of.interest, 
                lower.tail = FALSE, log.p = FALSE) - ncp)^2
        }
        .ci.nct.upper <- function(val.of.interest, ...) {
            (qt(p = alpha.upper, df = df, ncp = val.of.interest, 
                lower.tail = TRUE, log.p = FALSE) - ncp)^2
        }
        if (alpha.lower != 0) {
            if (sup.int.warns == TRUE) 
                Low.Lim <- suppressWarnings(optimize(f = .ci.nct.lower, 
                  interval = c(min.ncp, max.ncp), alpha.lower = alpha.lower, 
                  df = df, ncp = ncp, maximize = FALSE, tol = tol))
            if (sup.int.warns == FALSE) 
                Low.Lim <- optimize(f = .ci.nct.lower, interval = c(min.ncp, 
                  max.ncp), alpha.lower = alpha.lower, df = df, 
                  ncp = ncp, maximize = FALSE, tol = tol)
        }
        if (alpha.upper != 0) {
            if (sup.int.warns == TRUE) 
                Up.Lim <- suppressWarnings(optimize(f = .ci.nct.upper, 
                  interval = c(min.ncp, max.ncp), alpha.upper = alpha.upper, 
                  df = df, ncp = ncp, maximize = FALSE, tol = tol))
            if (sup.int.warns == FALSE) 
                Up.Lim <- optimize(f = .ci.nct.upper, interval = c(min.ncp, 
                  max.ncp), alpha.upper = alpha.upper, df = df, 
                  ncp = ncp, maximize = FALSE, tol = tol)
        }
        if (alpha.lower == 0) 
            Result <- list(Lower.Limit = -Inf, Prob.Less.Lower = 0, 
                Upper.Limit = Up.Lim$minimum, Prob.Greater.Upper = pt(q = ncp, 
                  ncp = Up.Lim$minimum, df = df))
        if (alpha.upper == 0) 
            Result <- list(Lower.Limit = Low.Lim$minimum, Prob.Less.Lower = pt(q = ncp, 
                ncp = Low.Lim$minimum, df = df, lower.tail = FALSE), 
                Upper.Limit = Inf, Prob.Greater.Upper = 0)
        if (alpha.lower != 0 & alpha.upper != 0) 
            Result <- list(Lower.Limit = Low.Lim$minimum, Prob.Less.Lower = pt(q = ncp, 
                ncp = Low.Lim$minimum, df = df, lower.tail = FALSE), 
                Upper.Limit = Up.Lim$minimum, Prob.Greater.Upper = pt(q = ncp, 
                  ncp = Up.Lim$minimum, df = df))
        if (sup.int.warns == TRUE) 
            options(warn = Orig.warn)
        return(Result)
    }
    .conf.limits.nct.M2 <- function(ncp, df, conf.level = NULL, 
        alpha.lower, alpha.upper, tol = 1e-09, sup.int.warns = TRUE, 
        ...) {
        .ci.nct.lower <- function(val.of.interest, ...) {
            (qt(p = alpha.lower, df = df, ncp = val.of.interest, 
                lower.tail = FALSE, log.p = FALSE) - ncp)^2
        }
        .ci.nct.upper <- function(val.of.interest, ...) {
            (qt(p = alpha.upper, df = df, ncp = val.of.interest, 
                lower.tail = TRUE, log.p = FALSE) - ncp)^2
        }
        if (sup.int.warns == TRUE) {
            Low.Lim <- suppressWarnings(nlm(f = .ci.nct.lower, 
                p = ncp, ...))
            Up.Lim <- suppressWarnings(nlm(f = .ci.nct.upper, 
                p = ncp, ...))
        }
        if (sup.int.warns == FALSE) {
            Low.Lim <- nlm(f = .ci.nct.lower, p = ncp, ...)
            Up.Lim <- nlm(f = .ci.nct.upper, p = ncp, ...)
        }
        if (alpha.lower == 0) 
            Result <- list(Lower.Limit = -Inf, Prob.Less.Lower = 0, 
                Upper.Limit = Up.Lim$estimate, Prob.Greater.Upper = pt(q = ncp, 
                  ncp = Up.Lim$estimate, df = df))
        if (alpha.upper == 0) 
            Result <- list(Lower.Limit = Low.Lim$estimate, Prob.Less.Lower = pt(q = ncp, 
                ncp = Low.Lim$estimate, df = df, lower.tail = FALSE), 
                Upper.Limit = Inf, Prob.Greater.Upper = 0)
        if (alpha.lower != 0 & alpha.upper != 0) 
            Result <- list(Lower.Limit = Low.Lim$estimate, Prob.Less.Lower = pt(q = ncp, 
                ncp = Low.Lim$estimate, df = df, lower.tail = FALSE), 
                Upper.Limit = Up.Lim$estimate, Prob.Greater.Upper = pt(q = ncp, 
                  ncp = Up.Lim$estimate, df = df))
        return(Result)
    }
    Res.M1 <- Res.M2 <- NULL
    try(Res.M1 <- .conf.limits.nct.M1(ncp = ncp, df = df, conf.level = NULL, 
        alpha.lower = alpha.lower, alpha.upper = alpha.upper, 
        tol = tol, sup.int.warns = sup.int.warns), silent = TRUE)
    if (length(Res.M1) != 4) 
        Res.M1 <- NULL
    try(Res.M2 <- .conf.limits.nct.M2(ncp = ncp, df = df, conf.level = NULL, 
        alpha.lower = alpha.lower, alpha.upper = alpha.upper, 
        tol = tol, sup.int.warns = sup.int.warns), silent = TRUE)
    if (length(Res.M2) != 4) 
        Res.M2 <- NULL
    Low.M1 <- Res.M1$Lower.Limit
    Prob.Low.M1 <- Res.M1$Prob.Less.Lower
    Upper.M1 <- Res.M1$Upper.Limit
    Prob.Upper.M1 <- Res.M1$Prob.Greater.Upper
    Low.M2 <- Res.M2$Lower.Limit
    Prob.Low.M2 <- Res.M2$Prob.Less.Lower
    Upper.M2 <- Res.M2$Upper.Limit
    Prob.Upper.M2 <- Res.M2$Prob.Greater.Upper
    Min.for.Best.Low <- min((c(Prob.Low.M1, Prob.Low.M2) - alpha.lower)^2)
    if (!is.null(Res.M1)) {
        if (Min.for.Best.Low == (Prob.Low.M1 - alpha.lower)^2) 
            Best.Low <- 1
    }
    if (!is.null(Res.M2)) {
        if (Min.for.Best.Low == (Prob.Low.M2 - alpha.lower)^2) 
            Best.Low <- 2
    }
    Min.for.Best.Up <- min((c(Prob.Upper.M1, Prob.Upper.M2) - 
        alpha.upper)^2)
    if (!is.null(Res.M1)) {
        if (Min.for.Best.Up == (Prob.Upper.M1 - alpha.upper)^2) 
            Best.Up <- 1
    }
    if (!is.null(Res.M2)) {
        if (Min.for.Best.Up == (Prob.Upper.M2 - alpha.upper)^2) 
            Best.Up <- 2
    }
    if (is.null(Res.M1)) {
        Low.M1 <- NA
        Prob.Low.M1 <- NA
        Upper.M1 <- NA
        Prob.Upper.M1 <- NA
    }
    if (is.null(Res.M2)) {
        Low.M2 <- NA
        Prob.Low.M2 <- NA
        Upper.M2 <- NA
        Prob.Upper.M2 <- NA
    }
    Result <- list(Lower.Limit = c(Low.M1, Low.M2)[Best.Low], 
        Prob.Less.Lower = c(Prob.Low.M1, Prob.Low.M2)[Best.Low], 
        Upper.Limit = c(Upper.M1, Upper.M2)[Best.Up], Prob.Greater.Upper = c(Prob.Upper.M1, 
            Prob.Upper.M2)[Best.Up])
    return(Result)
}

    
    sim.res<-as.data.frame(df_)
    colnames(sim.res)<-c("Observed","Expected")
    sim.res<-sim.res[order(sim.res$Expected),]
    
    #check equality of number of replicates
    x <- table(sim.res$Expected)
    if((max(x)-min(x))==0){
        
        #number of dilution levels
        ndat <- unname(x[1]) 
        
        #calculate within group variances for weights,
        #coefficient of variation for precision
        var.calc<-NA
        mean.calc<-NA
        cv.calc<-NA
        ci.cv.upper<-NA
        ci.cv.lower<-NA
        for(i in 1:length(x)){
            var.calc[i]<-var(sim.res[((i-1)*ndat+1):(i*ndat),1])
            mean.calc[i]<-mean(sim.res[((i-1)*ndat+1):(i*ndat),1])
            cv.calc[i]<-ci.cv(mean=mean.calc[i],sd=sqrt(var.calc[i]),n=max(x))$C.of.V
            ci.cv.lower[i]<-ci.cv(mean=mean.calc[i],sd=sqrt(var.calc[i]),n=max(x))$Lower.Limit.CofV
            ci.cv.upper[i]<-ci.cv(mean=mean.calc[i],sd=sqrt(var.calc[i]),n=max(x))$Upper.Limit.CofV
       }
        
        #calculate quadratic regression p value
        weights<-1/rep(var.calc,each=ndat)
        fit<-lm(sim.res[,1]~sim.res[,2]+I(sim.res[,2]^2),weights=weights)
        fit.quad<-fit
        quad.p<-coeftest(fit,vcov=vcovHC(fit,type="HC3"))[3,4]

        #calculate runs test p value    
        fit<-lm(sim.res[,1]~sim.res[,2],weights=weights)
        runs.p<-min(1,runs.test(fit$residuals,threshold=0,pvalue="exact")$p.value)

        #calculate freq block test p value
        vec <- fit$residuals
        N <- length(unique(sim.res$Expected))
        freq.p <- 1-pgamma(sum((colSums(matrix(vec>0,ncol=length(x)))-ndat*0.5)^2/(ndat*0.5)),N/2)

        #calculate f lack of fit test p value
        fit.fac <- lm(sim.res[,1]~factor(sim.res[,2]),weights=weights)
        lof.p <- anova(fit.fac,fit)[["Pr(>F)"]][2]
        
        #sign table
        step1 <- replace(as.character(unname(vec>0)),which((vec>0)=="FALSE"),"-")
        step2 <- replace(step1,which(step1=="TRUE"),"+")
        formatforprint <- (matrix(step2,ncol=ndat,byrow=TRUE))
        rownames(formatforprint) <- unique(sim.res[,2])
        colnames(formatforprint) <- 1:max(x)
        
        #cv table
        cvtable<-data.frame(CV=cv.calc*100,LL95=ci.cv.lower*100,UL95=ci.cv.upper*100)
        rownames(cvtable) <- unique(sim.res[,2])
        ndat<-unname(x)
        ndat.cum <- c(0,cumsum(unname(x)))
    } else {
        #number of dilution levels
        ndat <- unname(x)
        ndat.cum <- c(0,cumsum(unname(x)))
        #calculate within group variances for weights,
        #coefficient of variation for precision
        var.calc<-NA
        mean.calc<-NA
        cv.calc<-NA
        ci.cv.upper<-NA
        ci.cv.lower<-NA
        for(i in 1:length(x)){
            var.calc[i]<-var(sim.res[(ndat.cum[i]+1):ndat.cum[i+1],1])
            mean.calc[i]<-mean(sim.res[(ndat.cum[i]+1):ndat.cum[i+1],1])
            cv.calc[i]<-ci.cv(mean=mean.calc[i],sd=sqrt(var.calc[i]),n=max(x))$C.of.V
            ci.cv.lower[i]<-ci.cv(mean=mean.calc[i],sd=sqrt(var.calc[i]),n=unname(x)[i])$Lower.Limit.CofV
            ci.cv.upper[i]<-ci.cv(mean=mean.calc[i],sd=sqrt(var.calc[i]),n=unname(x)[i])$Upper.Limit.CofV
       }
        
        #calculate quadratic regression p value
        weights<-1/rep(var.calc,times=ndat)
        fit<-lm(sim.res[,1]~sim.res[,2]+I(sim.res[,2]^2),weights=weights)
        fit.quad<-fit
        quad.p<-coeftest(fit,vcov=vcovHC(fit,type="HC3"))[3,4]

        #calculate runs test p value    
        fit<-lm(sim.res[,1]~sim.res[,2],weights=weights)
        runs.p<-min(1,runs.test(fit$residuals,threshold=0,pvalue="exact")$p.value)

        #calculate freq block test p value
        vec <- fit$residuals
        N <- length(unique(sim.res$Expected))
        freq.p <- 1-pgamma(sum((colSums(matrix(vec>0,ncol=length(x)))-ndat*0.5)^2/(ndat*0.5)),N/2)

        #calculate f lack of fit test p value
        fit.fac <- lm(sim.res[,1]~factor(sim.res[,2]),weights=weights)
        lof.p <- anova(fit.fac,fit)[["Pr(>F)"]][2]
        
        #sign table
        step1 <- replace(as.character(unname(vec>0)),which((vec>0)=="FALSE"),"-")
        step2 <- replace(step1,which(step1=="TRUE"),"+")
        formatforprint <- (matrix("",ncol=max(ndat),nrow=length(ndat),byrow=TRUE))
        for(i in 1:length(ndat)){
        	fill <- step2[(ndat.cum[i]+1):ndat.cum[i+1]]
        	formatforprint[i,1:length(fill)]<-fill
        }
        rownames(formatforprint) <- unique(sim.res[,2])
        colnames(formatforprint) <- 1:max(x)
        
        #cv table
        cvtable<-data.frame(CV=cv.calc*100,LL95=ci.cv.lower*100,UL95=ci.cv.upper*100)
        rownames(cvtable) <- unique(sim.res[,2])
    }
```
Quadratic regression p-value: `r round(quad.p,4)`.

Runs test p-value: `r round(runs.p,4)`.

Frequency within a block test p-value: `r round(freq.p,4)`.

F test for lack of fit p-value: `r round(lof.p,4)`.

(Low p-values indicate deviation from linearity.)

Sign table:
```{r signtable, echo=FALSE}
library(knitr)
kable(formatforprint)
```

Coefficients of variation (in percentage) with 95% confidence intervals:
```{r cvtable, echo=FALSE}
kable(cvtable)
```

\newpage

Graphics
=======================

Linearity
-----------------------

Observed (red dots), average of observed (dashed line) and fitted (blue dots, full line) values.

```{r echo=FALSE}
library(MASS)
library(ggplot2)
library(cowplot)
df.for.plot<-data.frame(sim.res)
colnames(df.for.plot)<-c("obs","exp")
df.for.plot$obs[df.for.plot$obs<0]<-0

#calculate fitted values (blue dots)
a<-lm(obs~exp,data=df.for.plot,weights=weights)
preds <-predict(a, newdata=data.frame(exp=unique(df.for.plot$exp)))

#calculate average of observed values (dashed line)
groupmeans<-mean.calc

#calulate bias
dev.from.lin <- (groupmeans/preds-1)*100
names(dev.from.lin) <- unique(sim.res[,2])

#make plot
##########

#generate reference lines
plot <- list()
for(i in 1:length(preds)){
dataSubs <- data.frame(type=c("pred",rep("obs",times=ndat[i])), data=c(preds[i],df.for.plot$obs[(ndat.cum[i]+1):ndat.cum[i+1]]),exp=unique(df.for.plot$exp)[i])
infinite<-1
if(max(dataSubs$data[-1])/dataSubs$data[1]>=1/(min(dataSubs$data[-c(1,which(dataSubs$data==0))])/dataSubs$data[1])){
	cut <- (floor(max(dataSubs$data[-1])/dataSubs$data[1]*100)-100)/2/100
	level<-1+cut*2
	yint<- c()
	while(level>=min(dataSubs$data[-1])/dataSubs$data[1]&&infinite<20){
		if(level!=1){yint<-c(yint,level)}
		level<-level-cut
        infinite<-infinite+1
	}
} else {
	cut <- ((min(dataSubs$data[-1])/dataSubs$data[1]*100)-100)/2/100
	level<-1+cut*2
	yint<- c()
	while(level<=max(dataSubs$data[-1])/dataSubs$data[1]&&infinite<20){
		if(level!=1){yint<-c(yint,level)}
		level<-level-cut
        infinite<-infinite+1
    }
}

yint<-yint*unique(dataSubs$data[1])
if(length(yint)==0){
yint<-0
}
ylabs<-paste(round((yint/unique(dataSubs$data[1])-1)*100,2),"%",sep="")
if(length(which(ylabs=="0%"))>0){
yint<-yint[-which(ylabs=="0%")]
ylabs<-ylabs[-which(ylabs=="0%")]
}

#generate one plot per dilution level
#first plot deviates: y axis label
#middle plot deviates: x axis label
if(i==1){
plot[[i]] <- ggplot(dataSubs, aes(x=exp,y=data,colour=type)) +
  stat_smooth(method="lm",se=FALSE,size=0.2) +  
  theme_minimal() + geom_hline(yintercept=preds[i]) +
  geom_hline(yintercept=groupmeans[i],linetype=2) + geom_point() +
  geom_hline(yintercept=yint,linetype=3,alpha=0.25) + annotate("text",label=ylabs,y=yint,x=unique(dataSubs$exp),alpha=0.75,size=3) +
  scale_colour_brewer(palette = "Set1") +
  xlab("")+ylab("observed concentration") + theme(legend.position="none", axis.ticks.y=element_blank(),axis.text.y=element_blank()) + scale_x_discrete(limits=c(unique(df.for.plot$exp)[i]))	
} else if(i==ceiling(length(preds)/2)){
	plot[[i]] <- ggplot(dataSubs, aes(x=exp,y=data,colour=type)) +
  stat_smooth(method="lm",se=FALSE,size=0.2) +  
  theme_minimal() + geom_hline(yintercept=preds[i]) +
  geom_hline(yintercept=groupmeans[i],linetype=2) + geom_point() +
  geom_hline(yintercept=yint,linetype=3,alpha=0.25) + annotate("text",label=ylabs,y=yint,x=unique(dataSubs$exp),alpha=0.75,size=3) +
  scale_colour_brewer(palette = "Set1") +
  xlab("expected concentration")+ylab("") + theme(legend.position="none", axis.ticks.y=element_blank(),axis.text.y=element_blank()) + scale_x_discrete(limits=c(unique(df.for.plot$exp)[i]))
} else {
plot[[i]] <- ggplot(dataSubs, aes(x=exp,y=data,colour=type)) +
  stat_smooth(method="lm",se=FALSE,size=0.2) +  
  theme_minimal() + geom_hline(yintercept=preds[i]) +
  geom_hline(yintercept=groupmeans[i],linetype=2) + geom_point() +
  geom_hline(yintercept=yint,linetype=3,alpha=0.25) + annotate("text",label=ylabs,y=yint,x=unique(dataSubs$exp),alpha=0.75,size=3) +
  scale_colour_brewer(palette = "Set1") +
  xlab("")+ylab("") + theme(legend.position="none", axis.ticks.y=element_blank(),axis.text.y=element_blank()) + scale_x_discrete(limits=c(unique(df.for.plot$exp)[i]))
}
}
dev.plot <- (plot_grid(plotlist=plot, align='h', labels=c('', '', '', '', '', '', ''),nrow=1))
```
```{r linplot, echo=FALSE,fig.width=6, fig.height=4}
dev.plot
```

Deviation from fit (in percentage):
```{r lintable, echo=FALSE}
kable(dev.from.lin)
```

\newpage

Accuracy
-----------------------
Observed (red dots), average of observed (dashed line) and expected (blue dots, full line) values. 

```{r echo=FALSE, warning=FALSE}
#calculate perfect accuracy fit
sim.res[,3]<-sim.res[,2]
df.for.plot<-data.frame(sim.res)
colnames(df.for.plot)<-c("obs","exp")
a <- lm(sim.res[,3]~0+sim.res[,2],weights=weights)

#calculate expected values (blue dots)
preds <-unique(predict(a, newdata=data.frame(exp=unique(df.for.plot$exp))))

#calculate average of observed values (dashed line)
groupmeans<-mean.calc

#calulate bias
dev.from.acc <- (groupmeans/preds-1)*100
names(dev.from.acc) <- unique(sim.res[,2])

#make plot
##########

#generate reference lines
plot <- list()
for(i in 1:length(preds)){
dataSubs <- data.frame(type=c("pred",rep("obs",ndat[i])), data=c(preds[i],df.for.plot$obs[(ndat.cum[i]+1):ndat.cum[i+1]]),exp=unique(df.for.plot$exp)[i])
infinite<-1
if(max(dataSubs$data[-1])/dataSubs$data[1]>1/(min(dataSubs$data[-c(1,which(dataSubs$data==0))])/dataSubs$data[1])){
	cut <- (floor(max(dataSubs$data[-1])/dataSubs$data[1]*100)-100)/2/100
	level<-1+cut*2
	yint<- c()
	while(level>min(dataSubs$data[-1])/dataSubs$data[1]&&infinite<20){
		if(level!=1){yint<-c(yint,level)}
		level<-level-cut
        infinite<-infinite+1
	}
} else {
	cut <- (ceiling(min(dataSubs$data[-1])/dataSubs$data[1]*100)-100)/2/100
	level<-1+cut*2
	yint<- c()
	while(level<max(dataSubs$data[-1])/dataSubs$data[1]&&infinite<20){
		if(level!=1){yint<-c(yint,level)}
		level<-level-cut
        infinite<-infinite+1
	}
}

yint<-yint*unique(dataSubs$data[1])
if(length(yint)==0){
yint<-0
}
ylabs<-paste(round((yint/unique(dataSubs$data[1])-1)*100,2),"%",sep="")
if(length(which(ylabs=="0%"))>0){
yint<-yint[-which(ylabs=="0%")]
ylabs<-ylabs[-which(ylabs=="0%")]
}

#generate one plot per dilution level
#first plot deviates: y axis label
#middle plot deviates: x axis label
if(i==1){
plot[[i]] <- ggplot(dataSubs, aes(x=exp,y=data,colour=type)) +
  stat_smooth(method="lm",se=FALSE,size=0.2) +  
  theme_minimal() + geom_hline(yintercept=preds[i]) +
  geom_hline(yintercept=groupmeans[i],linetype=2) + geom_point() +
  geom_hline(yintercept=yint,linetype=3,alpha=0.25) + annotate("text",label=ylabs,y=yint,x=unique(dataSubs$exp),alpha=0.75,size=3) +
  scale_colour_brewer(palette = "Set1") +
  xlab("")+ylab("observed concentration") + theme(legend.position="none", axis.ticks.y=element_blank(),axis.text.y=element_blank()) + scale_x_discrete(limits=c(unique(df.for.plot$exp)[i]))	
} else if(i==ceiling(length(preds)/2)){
	plot[[i]] <- ggplot(dataSubs, aes(x=exp,y=data,colour=type)) +
  stat_smooth(method="lm",se=FALSE,size=0.2) +  
  theme_minimal() + geom_hline(yintercept=preds[i]) +
  geom_hline(yintercept=groupmeans[i],linetype=2) + geom_point() +
  geom_hline(yintercept=yint,linetype=3,alpha=0.25) + annotate("text",label=ylabs,y=yint,x=unique(dataSubs$exp),alpha=0.75,size=3) +
  scale_colour_brewer(palette = "Set1") +
  xlab("expected concentration")+ylab("") + theme(legend.position="none", axis.ticks.y=element_blank(),axis.text.y=element_blank()) + scale_x_discrete(limits=c(unique(df.for.plot$exp)[i]))
} else {
plot[[i]] <- ggplot(dataSubs, aes(x=exp,y=data,colour=type)) +
  stat_smooth(method="lm",se=FALSE,size=0.2) +  
  theme_minimal() + geom_hline(yintercept=preds[i]) +
  geom_hline(yintercept=groupmeans[i],linetype=2) + geom_point() +
  geom_hline(yintercept=yint,linetype=3,alpha=0.25) + annotate("text",label=ylabs,y=yint,x=unique(dataSubs$exp),alpha=0.75,size=3) +
  scale_colour_brewer(palette = "Set1") +
  xlab("")+ylab("") + theme(legend.position="none", axis.ticks.y=element_blank(),axis.text.y=element_blank()) + scale_x_discrete(limits=c(unique(df.for.plot$exp)[i]))
}
}
dev.plot <- (plot_grid(plotlist=plot, align='h', labels=c('', '', '', '', '', '', ''),nrow=1))
```
```{r accplot, echo=FALSE,fig.width=6, fig.height=4}
dev.plot
```

Deviation from accuracy (in percentage):
```{r acctable, echo=FALSE}
kable(dev.from.acc)
```

\newpage

Data
=======================

```{r kable, echo=FALSE}
kable(df_, digits=4)
```

\newpage

Additional information
=======================

Quadratic regression model coefficients:
```{r, echo=FALSE}
coef.quad <- coef(fit.quad)
names(coef.quad)<-c("intercept","linear","quadratic")
print(coef.quad)
```
Quadratic regression model covariance matrix:
```{r, echo=FALSE}
vcov.quad <- vcovHC(fit.quad,type="HC3")
colnames(vcov.quad) <- c("intercept","linear","quadratic")
rownames(vcov.quad) <- c("intercept","linear","quadratic")
print(vcov.quad)
```

Simple linear regression model coefficients:
```{r, echo=FALSE}
coef.simple <- coef(fit)
names(coef.simple)<-c("intercept","slope")
print(coef.simple)
```
Simple linear regression model covariance matrix:
```{r, echo=FALSE}
vcov.simple <- vcovHC(fit,type="HC3")
colnames(vcov.simple) <- c("intercept","slope")
rownames(vcov.simple) <- c("intercept","slope")
print(vcov.simple)
```